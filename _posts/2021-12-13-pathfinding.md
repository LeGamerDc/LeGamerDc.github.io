---
layout: default
title: 寻路算法笔记
use_math: true
---

## 寻路算法笔记

最近在看寻路方面的资料，包括unity支持的寻路算法(recast nav)，知名slg游戏的寻路实现(帝国时代，星际2)，以及论文。其中很多算法着眼于实施碰撞，动态地图，网格寻路，障碍避免这些虽然很有趣，但是短时间无法应用到我们的游戏里面；除此之外，也不乏一些实现上的trick，优化等，这些方面可能应用于我们的游戏中，我在这里记录一下这些我在查看资料中碰到的我认为可以应用到我们系统中的点。最终我将重新实现一套寻路库，一方面是为了减少目前寻路库中的gc开销(使用index替代指针)；另一方面，可以把一些优化点应用进来。

当然，本笔记也会记录一些有趣但暂时不能应用到我们游戏的算法，一来拓宽一下视野，二来为未来的游戏开发做技术储备。

### 1. $A^* 优化_1$

我们都知道在astar[算法](https://en.wikipedia.org/wiki/A*_search_algorithm)中，最影响算法速度的优化点即是对`h`函数的预估:
$$
f(n) = g(n) + h(n)\ \ \ \ when\ \ \ \ h(n) <= c(n)
$$
其中，`h(n)`越接近`c(n)`，寻路速度越快，当`h(n)=c(n)`时，算法退化到没有搜索直接求出最短路径。朴素的思路是使用两点间的直线距离`s(n)`作为`h(n)`，但是当地形复杂时，直线距离往往与最短距离相差巨大。一种优化方案是，在地图中设一个点`x`，预求出点`x`到任意点`n`的最短距离`d(n)`，那么很显然`|d(a)-d(b)| <= c(a, b)`，且，如果点`x`到点`a`与点`b`的最短距离顺路，那么`|d(a)-d(b)|=c(a,b)`，即达到了最优预估。这种方式使得在场景复杂的情况下节省非常多的寻路时间。

考虑到点`x`到点`a`与`b`最短距离无关时，上述估值函数与`c(a,b)`差值较大，一种合理的估值函数是:
$$
f(a,b) = max(|d(a)-d(b)|, c(a, b))
$$
一般点`x`选择地图原地坐标，使得每个迷宫区域的点尽量顺路。

### 2. $A^* 优化_2$

这个优化非常朴实，我们希望存储地图中任意两点`s,t`的最短路径，但是开销巨大，一种合理的缓存方式是缓存下一跳，即从`s`到`t`的最短路径中的下一个点，考虑若`n(s,t)=a`表示`s`到`t`的最短距离下一跳到`a`，那么求最短路径可以递归地求解为`path(s,t)=n(s,t),path(n(s,t),t)=a,path(a,t)=a,n(a,t),path(n(a,t),t)=a,b,path(b,t)`。我们可以使用`LRU`的方式缓存`n(x, y)=a`表。

`LRU`一种简单的实现是维护一个`node{s,t,a,next int32}`的队列，以及使用`node`的`next`字段维护hash key的链表，可以实现近似`O(1)`的插入/查找，详细代码参考`jumpcache.go`

### 3. 一种实现的很好的pathfinding

使用多边形邻接边的中点作为路点，多边形各个边的路点连接做寻路边，加入起点和终点一起寻路，寻路空间使用mesh做单位(每个mesh 只会在寻路空间中存在一次)，使得该算法性能非常高，同时寻路结果也相当优秀。具体参考 [pathfinding](172.16.2.222/dongcheng/lib_chaos)

### 4. Point location优化$_1$

`point location`指给定一个点`q`，找出包含点`q`的多边形`p`。常见的方法是遍历`tile`中的所有多边形，依次判定多边形是否包含点`q`。一种优化的方案是初始化时给出`tile`中的`m`个初始点$[y_1, y_2,...,y_m]$，以及包含他们的多边形$[p_1,p_2,...,p_m]$，当需要寻找包含点`x`的多边形时，首先找到$i\in[1,2,...,m]$使得$distance(x,y_i)$距离最小，则我们可以沿线段$y_i,x$从$p_i$多边形找到包含$x$的多边形$X$。该方法需要一个前置条件，即`tile`内无镂空，不过考虑到我们为了减少多边形数量，常常剔除掉无法行走的mesh，我们可以先使用该方案当无法成功时再使用遍历的方案。

### 5. relax精确寻路

一般，当我们从堆里拿出的mesh是终点mesh时，寻路就结束了，这时根据node可以反推一条路径。但是由于mesh邻接点的选择，寻路出来的`g` 与实际`c`存在一定误差，使得我们选择的并不一定是真实的最短路径。这时，如果我们对寻路结果有更高的需求，可以用使用relax，当首次寻路到终点mesh时，我们对该路径进行pull得到真实`c`，然后设置`lastBestCost=c`，并且设置`searchThreshHold=lastBestCost*1.2`（其中1.2是经验值），然后要求接下来加入堆的node的`f<searchThreshHold`，然后每次搜索到终点mesh时，都更新`lastBestCost`与`searchThreshHold`，当堆空时，我们就得到了更优的寻路路径。

不过该方案有一个缺点，如果在路径中途存在非最优路径，那么是没办法去除的。

### 6. samo 高速路方案

samo高速路方案最大的问题是，高速路的存在使得可能`h(n) > c(n)`，破坏了最优路径的算法支持，因此，我们只能使用relax算法，拓展更多的结点进入堆，才能寻到高速路；其次，路点的选择也有讲究，朴素的寻路算法使用邻接mesh边的中点作为路点，这配合cdt mesh能生成较好的寻路结果(如果狭长三角形较多，对寻路结果有影响)，而高速路相当于在地图中安排了相当多的狭长三角形mesh，这使得我们寻路结果并不好，因此我们觉得在多边形的边上进行插值路点，使得路点更加密集来解决该问题。当然，同时使用插值点(寻路空间变大非常多)和relax算法使得我们的寻路速度相当慢，😭。

### 7. Delaunay剖分

[算法](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.6477&rep=rep1&type=pdf#:~:text=Degenerations%20such%20as%20edge%20overlapping,of%20dynamic%20polygo%2D%20nal%20domains.)记录了星际2所用的navmesh构造及寻路的算法，鉴于文章非常复杂，我们先从简单的定理开始描述。

1. 实数平面$R^2$的一组点$V$，由这些点组成的边$E$，组成的集合构成三角剖分$T=(V, E)$。当满足以下条件时：任何边$e$仅包含端点的2个点$v$；任何两条边不相交；所有的构成图形都是三角形。
2. 如果三角剖分中的一条边$e$满足存在一个圆过边的两个端点$v_1, v_2$，且圆不包含$V$中其他点，则该边可以称为`Delaunay`边；如果三角形的三条边都是`Delaunay`边，则该三角形可以称为`Delaunay`三角形；如果三角剖分的每条边都满足`Delaunay`边，那么可以称该剖分为`Delaunay`剖分。
3. `Delaunay`有等价特性：1. 对三角剖分$T=(V,E)$中的任意三角形$t$，$t$的外接圆不包含$V$中点$v$，则该三角剖分为`Delaunay`剖分；2.对三角剖分$T=(V,E)$，任意边邻接的三角形$t_1,t_2$，其组成的四边形$s$，使用另外一组对角线进行剖分得$t_3,t_4$，若$t_1,t_2$三角形的最小角角度不小于$t3,t4$三角形的最小角角度，那么$T$是`Delaunay`剖分，这个特性称为最大最小角特性。
4. 对一组限制$S=\{C_1,C_2,...,C_m\}$，其中$C_i$表示由$n$个点组成的线段，$T(S)=(V,E)$称为受限的`Delaunay`剖分，当满足一下条件：对$S$中的任意一组限制$C_i$，$E$中存在一组边的集合可以组成$C_i$，这些边称为受限的边；对$S$中的任意点$u$，$V$中存在点$v=u$；对$E$中不受限的边$e$，需要满足`Delaunay`边。

- 我们可以发现构建navmesh可以使用受限`Delaunay`剖分，其中受限的边为地图中的障碍，不受限的边则是可以通过的边；另外，由于最大最小角特性，生成的三角剖分更加不易存在细长三角，而细长三角是导致$A^*$寻路算法中出现非最右路径的最大原因；最后，`Delaunay`剖分比较容易进行动态调整，可以较小复杂度地支持动态增加/删除受限边，在寻路中可以体现为增加/移除障碍，正是这个特征，使得`Delaunay`剖分被星际争霸2使用。

5. 

